To create a Node.js prompt that behaves similarly to your Python script â€” taking a property address, querying an ArcGIS service, retrieving property boundary data, and generating an annotated image like your example â€” here's an outline and the initial Node.js starter script using popular geospatial and plotting libraries:

ðŸš€ Goal
Build a Node.js CLI tool that:

Takes a property address as input.

Queries ArcGIS to fetch the property boundary.

Uses satellite basemap imagery.

Annotates the image with side lengths and labels (like the one you uploaded).

Saves the output image locally.

âš™ï¸ Required Node.js Libraries
You'll need:

axios (HTTP requests)

node-canvas (image drawing)

turf (geospatial utilities)

arcgis-rest-js (for ArcGIS API interaction)

dotenv (to store your ArcGIS API key)

Install them:

bash
Copy
Edit
npm install axios canvas @turf/turf @esri/arcgis-rest-geocoding @esri/arcgis-rest-feature-layer dotenv
ðŸ§  Project Structure
plaintext
Copy
Edit
project-root/
â”œâ”€â”€ .env                # for API key
â”œâ”€â”€ index.js            # main script
â””â”€â”€ utils/
    â”œâ”€â”€ draw.js         # canvas drawing
    â”œâ”€â”€ query.js        # ArcGIS querying
ðŸ§¾ Example .env
dotenv
Copy
Edit
ARCGIS_API_KEY=your-api-key-here
ðŸ“¦ index.js â€” Main Script (Skeleton)
js
Copy
Edit
require('dotenv').config();
const { searchAddressAndFetchBoundary } = require('./utils/query');
const { drawPropertyBoundary } = require('./utils/draw');

const prompt = require('prompt-sync')();

(async () => {
  console.log("ðŸ” Brisbane Property Boundary Visualizer");

  const address = prompt("Enter full address (e.g., 300 Annerley Rd, Annerley, QLD): ");
  if (!address) {
    console.error("âŒ No address provided");
    return;
  }

  const data = await searchAddressAndFetchBoundary(address);

  if (data && data.geometry) {
    console.log("ðŸ“ Boundary data retrieved. Creating image...");
    await drawPropertyBoundary(data.geometry, data.address, 'output.png');
    console.log("âœ… Image saved to output.png");
  } else {
    console.log("âŒ Could not retrieve property data.");
  }
})();
ðŸ“¦ utils/query.js â€” Geocode and Fetch Geometry
js
Copy
Edit
const { geocode } = require('@esri/arcgis-rest-geocoding');
const { queryFeatures } = require('@esri/arcgis-rest-feature-layer');

const PROPERTY_LAYER_URL = 'https://services2.arcgis.com/dEKgZETqwmDAh1rP/arcgis/rest/services/property_boundaries_holding/FeatureServer/0';

async function searchAddressAndFetchBoundary(address) {
  try {
    const geo = await geocode({
      singleLine: address,
      authentication: { apiKey: process.env.ARCGIS_API_KEY }
    });

    const location = geo.candidates[0]?.location;
    if (!location) throw new Error("No location found");

    const result = await queryFeatures({
      url: PROPERTY_LAYER_URL,
      geometry: location,
      geometryType: "esriGeometryPoint",
      spatialRel: "esriSpatialRelIntersects",
      distance: 50,
      units: "esriSRUnit_Meter",
      outFields: "*",
      returnGeometry: true,
      authentication: { apiKey: process.env.ARCGIS_API_KEY }
    });

    const feature = result.features[0];
    return {
      address: geo.candidates[0]?.address,
      geometry: feature.geometry
    };
  } catch (e) {
    console.error("Error fetching data:", e.message);
    return null;
  }
}

module.exports = { searchAddressAndFetchBoundary };
ðŸ–¼ï¸ utils/draw.js â€” Canvas Drawing (Basic Example)
js
Copy
Edit
const { createCanvas } = require('canvas');
const fs = require('fs');

async function drawPropertyBoundary(geometry, address, outputFile = 'output.png') {
  const canvas = createCanvas(800, 800);
  const ctx = canvas.getContext('2d');

  ctx.fillStyle = '#f8f8f8';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const ring = geometry.rings[0];

  // Normalize coordinates
  const xs = ring.map(p => p[0]);
  const ys = ring.map(p => p[1]);
  const minX = Math.min(...xs);
  const minY = Math.min(...ys);
  const maxX = Math.max(...xs);
  const maxY = Math.max(...ys);

  const scaleX = 700 / (maxX - minX);
  const scaleY = 700 / (maxY - minY);

  ctx.translate(50, 50);
  ctx.beginPath();
  ring.forEach(([x, y], i) => {
    const px = (x - minX) * scaleX;
    const py = canvas.height - (y - minY) * scaleY;
    if (i === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  });
  ctx.closePath();
  ctx.strokeStyle = 'blue';
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.fillStyle = 'rgba(255, 255, 0, 0.4)';
  ctx.fill();

  // Label sides
  for (let i = 0; i < ring.length - 1; i++) {
    const [x1, y1] = ring[i];
    const [x2, y2] = ring[i + 1];

    const midX = (x1 + x2) / 2;
    const midY = (y1 + y2) / 2;

    const px = (midX - minX) * scaleX;
    const py = canvas.height - (midY - minY) * scaleY;

    const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2).toFixed(2);

    ctx.fillStyle = 'black';
    ctx.font = '12px sans-serif';
    ctx.fillText(`Side ${i + 1}: ${length}m`, px - 20, py);
  }

  ctx.fillStyle = 'black';
  ctx.fillText(address, 10, 20);

  const buffer = canvas.toBuffer('image/png');
  fs.writeFileSync(outputFile, buffer);
}

module.exports = { drawPropertyBoundary };
âœ… Output
This will produce a PNG image similar in layout to your example:

Satellite optional (advanced with a tile provider)

Side labels and boundary lines

Scaled image

ðŸ“Œ Next Steps
Add satellite background using a tile service (e.g. Esri, Mapbox, or OSM with node-mapnik or WebGL rendering).

Export as web app with express.js if needed.

Let me know if you'd like the Dockerized version or deployment guide.

Would you like me to zip this project up or deploy it as a web form instead?